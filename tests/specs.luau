--!strict
local Runner = require("test_runner")
local QueryBuilder = require("../src/init")
local define = QueryBuilder.define

local d: any = Runner.Describe
local it: any = Runner.Test
local expect: any = Runner.Expect

return function()
	d("QueryBuilder Properties", function()
		it("should handle basic property equality", function()
			local q = QueryBuilder.fromOperation(function(x)
				return x.ClassName == define("Model")
			end):ToQuery()
			expect(q).ToEqual("Model")
		end)

		it("should handle define() wrapper", function()
			local q = QueryBuilder.fromOperation(function(x)
				return x.Name == define("Part")
			end):ToQuery()
			expect(q).ToEqual("#Part")
		end)

        it("should handle numeric properties", function()
            -- Numeric prop isn't mapped to Class/Name/Id helper, but standard [Prop=Val]
            local q = QueryBuilder.fromOperation(function(x)
                return x.Transparency == define(1)
            end):ToQuery()
            expect(q).ToContain("[Transparency = 1]")
        end)
	end)

    d("QueryBuilder Attributes", function()
        it("should handle GetAttribute", function()
             local q = QueryBuilder.fromOperation(function(x)
                 return x:GetAttribute("MyKey") == define("MyVal")
             end):ToQuery()
             expect(q).ToEqual("[$MyKey = \"MyVal\"]")
        end)

        it("should handle GetAttribute with define", function()
             local q = QueryBuilder.fromOperation(function(x)
                 return x:GetAttribute("Level") == define(5)
             end):ToQuery()
             expect(q).ToEqual("[$Level = 5]")
        end)
    end)

    d("QueryBuilder Children", function()
        it("should handle FindFirstChild (Recursive=false)", function()
            local q = QueryBuilder.fromOperation(function(x)
                return x:FindFirstChild("ChildName")
            end):ToQuery()
            -- :has(> #ChildName)
            expect(q).ToContain(":has(> #ChildName)")
        end)

        it("should handle FindFirstChild (Recursive=true)", function()
             local q = QueryBuilder.fromOperation(function(x)
                return x:FindFirstChild("DescendantName", true)
            end):ToQuery()
            -- :has(>> #DescendantName)
            expect(q).ToContain(":has(#DescendantName)")
        end)

         it("should handle FindFirstChildWhichIsA", function()
             local q = QueryBuilder.fromOperation(function(x)
                return x:FindFirstChildWhichIsA("Part")
            end):ToQuery()
            -- :has(> Part)
            expect(q).ToContain(":has(> Part)")
        end)
        
        it("should handle nested attributes", function()
            local q = QueryBuilder.fromOperation(function(x)
                local child = x:FindFirstChild("ChildName")
                return child:GetAttribute("Test") == define(true)
            end):ToQuery()
            -- :has(> #ChildName[$Test = true])
            expect(q).ToContain(":has(> #ChildName[$Test = true])")
        end)

        it("should handle nested properties", function()
             local q = QueryBuilder.fromOperation(function(x)
                 local child = x:FindFirstChild("ChildName")
                 return child.Transparency == define(0.5)
             end):ToQuery()
             -- :has(> #ChildName[Transparency = 0.5])
             expect(q).ToContain(":has(> #ChildName[Transparency = 0.5])")
        end)
        
        it("should handle recursive nested checks", function()
             local q = QueryBuilder.fromOperation(function(x)
                 local child = x:FindFirstChild("DescendantName", true)
                 return child:GetAttribute("Active") == define(true) and child.Name == define("Target")
             end):ToQuery()
             -- :has(#DescendantName[Name = "Target"][$Active = true])
             expect(q).ToContain(":has(#DescendantName[Name = \"Target\"][$Active = true])")
        end)

        it("should handle nested negation", function()
             local q = QueryBuilder.fromOperation(function(x)
                 local child = x:FindFirstChild("ChildName")
                 return child.Transparency ~= define(1)
             end):ToQuery()
             -- :has(> #ChildName:not([Transparency = 1]))
             expect(q).ToContain(":has(> #ChildName:not([Transparency = 1]))")
        end)
    end)

    d("QueryBuilder Tags", function()
        it("should handle table.find(Tags)", function()
            local q = QueryBuilder.fromOperation(function(x)
                return table.find(x.Tags, "MyTag")
            end):ToQuery()
            expect(q).ToContain(".MyTag")
        end)
    end)
    
    d("QueryBuilder Negation", function()
         it("should handle negation", function()
            local q = QueryBuilder.fromOperation(function(x)
                return x.Name ~= define("Bad")
            end):ToQuery()
            -- :not(#Bad)
            expect(q).ToContain(":not(#Bad)")
         end)
    end)

    d("QueryBuilder Complex Queries", function()
        it("should handle complex queries", function()
            local q = QueryBuilder.fromOperation(function(x)
                local Prompt = x:FindFirstChildWhichIsA("ProximityPrompt", true)
                if Prompt and Prompt.Name == define("Interaction") then
                    return x.Name == define("InteractablePart")
                end

                return x.Name == define("Part")
            end):ToQuery()
            expect(q).ToContain("#Part")
            expect(q).ToContain("#InteractablePart")
        end)
    end)
end
